# Домашнее задание 2

## Дедлайн

26 декабря 23:59 (UTC + 3).

С возможностью присылать исправления для некритичных багов после дедлайна.

Целью этого домашнего задания является реализация простого однотактного процессора, который реализует
маленькое модмножество архитектуры MIPS (команды `lw`, `sw`, `add`, `sub`, `and`, `or`, `slt`, `beq`),
с помощью Verilog.

## **DISCLAMER**

При реализации данного домашнего задания **запрещается** переименовывать порты модулей, сами модули
и названия файлов, в которых они лежат, иначе вы ССЗБ.

Разрешается изменение типов портов, например с `output [31:0] port` на `output reg [31:0] port`.

## Часть 1

### Реализация составных частей микроархитектуры.

В этой части вам будет необходимо реализовать некоторые составные части вашей микроархитектуры,
а именно:
* АЛУ, [шаблон для реализации](./cpu_template/alu.v). [3 балла]
* Управляющее устройство, [шаблон для реализации](./cpu_template/control_unit.v). [3 балла]
* Регистровый файл, [шаблон для реализации](./cpu_template/register_file.v). [2 балла]
* Устройства памяти команд и данных, [шаблон для реализации](./cpu_template/memory.v) [2 балла]

Чтение из памяти и регистрового файла асинхронное, запись происходит по фронту сигнала синхронизации.

Обратите внимание, что память команд изначально заполняется двоичными данными из файла и является read-only.

Команды кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| lw      | 100011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| sw      | 101011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| beq     | 000100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| addi*   | 001000 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

`imm` для команды `beq` задает количество инструкций, на которое нужно сдвинуться относительно _следующей_ за `beq`.

`imm` -- знаковая 16-битная константа.

`*` Реализация `addi` является опциональной и может принести еще 2 дополнительных балла за реализацию
управляющего устройства.

| Команда | opcode | rs    | rt    | rd    | shamt | funct  |
|---------|--------|-------|-------|-------|-------|--------|
| add     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100000 |
| sub     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100010 |
| and     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100100 |
| or      | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100101 |
| slt     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 101010 |

Напонимание: биты нумеруются справа налево, т.е. самый правый бит является самым младшим битом команды:)

## Часть 2

### Реализация процессора

В этой части вам будет необходимо склеить модули из предыдущей части воедино, чтобы
получить рабочий процессор:)

Для этого вам нужно будет написать реализацию используя шаблон [`mips_cpu.v`](./cpu_template/mips_cpu.v).

Данный модуль имеет порт тактового генератора и порты для взаимодействия с памятью команд, данных
и регистровым файлом.

Для тестирования вашего процессора можете воспользоваться шаблоном [`cpu_test.v`](./cpu_template/cpu_test.v),
это единственный модуль, который вы можете менять как вам хочется:)

При реализации процессора вам могут понадобиться вспомогательные модули для мультиплексоров, расширения знаковой константы,
D-триггер для `PC` и тд. Вы можете использовать их реализацию из файла [`util.v`](./cpu_template/util.v).

Данная часть оценивается еще в 10 баллов.

Примеры программ для запуска вы можете найти [вот тут](./programs_samples/README.md).

## Формат сдачи

Файлы с решением данного домашнего задания должны называться `alu.v`, `control_unit.v`, `memory.v`,
`mips_cpu.v`, `register_file.v`, `util.v`.

Ваше письмо должно содержать ровно эти шесть файлов.

Сжимать эти файлы в один архив и прикреплять его к письму не нужно.
Помещать код в текст письма, прикреплять pdf'ки или изображения также не нужно.

Тема должна быть равна "ДЗ-2" (без кавычек). Если Вы хотите прислать исправление, пришлите новое письмо (по таким же правилам),
прикрепив к нему все шесть файлов (даже если вы изменяли только один из них). Во избежание путаницы, можете написать в тексте письма
(не в теме), что именно было исправлено. Проверяться будет последнее письмо с данной темой, присланное "до дедлайна".